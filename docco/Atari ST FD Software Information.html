<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<title>Atari ST FD Software Information</title>
<meta name="description" content="Atari ST Diskette Information">
<meta name="AUTHOR" content="Jean Louis-Guerin">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="Atari%20ST%20FD%20Software%20Information_files/infoCoach.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="Atari%20ST%20FD%20Software%20Information_files/atari.css">
<script type="text/javascript" async="" src="Atari%20ST%20FD%20Software%20Information_files/ga.js"></script><script src="Atari%20ST%20FD%20Software%20Information_files/SpryMenuBar.js" type="text/javascript"></script>
<link href="Atari%20ST%20FD%20Software%20Information_files/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css">

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7991018-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


</head>
<body class="oneCol">
<div id="container">
  <div id="header">
    <h1> Atari  ST FD Software</h1>
    <p>Last updated 
      <!-- #BeginDate format:Am1a -->January 15, 2015 3:51 PM<!-- #EndDate --> 
    </p>
    <div id="siteNavBar">
<ul>
<li><a href="https://info-coach.fr/index.php">Home</a></li>
<li><a href="https://info-coach.fr/atari/index.php" id="current">Atari</a></li>
<li><a href="https://info-coach.fr/pc/index.php">Pc</a></li>
<li><a href="https://info-coach.fr/research/index.php">Research</a></li>
</ul>
</div>
<ul id="secNavBar" class="MenuBarHorizontal">
<li><a class="MenuBarItemSubmenu" href="https://info-coach.fr/atari/documents/index.php">Documents</a>
<ul>
<li><a href="https://info-coach.fr/atari/documents/myFAQ.php" tabindex="-1">MyFAQ</a></li>
<li><a href="https://info-coach.fr/atari/documents/myDoc.php" tabindex="-1">MyDoc</a></li>
<li><a href="https://info-coach.fr/atari/documents/general.php" tabindex="-1">General</a></li>
<li><a href="https://info-coach.fr/atari/documents/datasheets.php" tabindex="-1">Datasheets</a></li>
</ul></li>
<li><a class="MenuBarItemSubmenu" href="https://info-coach.fr/atari/hardware/index.php" tabindex="-1">Hardware</a>
<ul>
<li><a href="https://info-coach.fr/atari/hardware/FD-Hard.php" tabindex="-1">FD-Hard</a></li>
<li><a href="https://info-coach.fr/atari/hardware/HD-Hard.php" tabindex="-1">HD-Hard</a></li>
<li><a class="MenuBarItemSubmenu" href="https://info-coach.fr/atari/hardware/devices/index.php" tabindex="-1">Devices</a>
<ul>
<li><a href="https://info-coach.fr/atari/hardware/devices/CosmosEx.php" tabindex="-1">CosmosEx</a></li>
<li><a href="https://info-coach.fr/atari/hardware/devices/supercard.php" tabindex="-1">Supercard</a></li>
<li><a href="https://info-coach.fr/atari/hardware/devices/kryoflux.php" tabindex="-1">Kryoflux</a></li>
<li><a href="https://info-coach.fr/atari/hardware/devices/DC.php" tabindex="-1">DC</a></li>
</ul></li>
<li><a href="https://info-coach.fr/atari/hardware/STE-HW.php" tabindex="-1">STE-HW</a></li>
<li><a href="https://info-coach.fr/atari/hardware/interfaces.php" tabindex="-1">Interfaces</a></li>
<li><a href="https://info-coach.fr/atari/hardware/video.php" tabindex="-1">Video</a></li>
<li><a href="https://info-coach.fr/atari/hardware/memory.php" tabindex="-1">Memory</a></li>
<li><a href="https://info-coach.fr/atari/hardware/disasembly.php" tabindex="-1">Disasembly</a></li>
</ul></li>
<li><a class="MenuBarItemSubmenu" href="https://info-coach.fr/atari/software/index.php" id="current" tabindex="-1">Software</a>
<ul>
<li><a href="https://info-coach.fr/atari/software/FD-Soft.php" tabindex="-1">FD-Soft</a></li>
<li><a href="https://info-coach.fr/atari/software/HD-Soft.php" tabindex="-1">HD-Soft</a></li>
<li><a class="MenuBarItemSubmenu" href="https://info-coach.fr/atari/software/PC-projects/index.php" tabindex="-1">PC-projects</a>
<ul>
<li><a href="https://info-coach.fr/atari/software/PC-projects/Aufit.php" tabindex="-1">Aufit</a></li>
<li><a href="https://info-coach.fr/atari/software/PC-projects/analyzer.php" tabindex="-1">Analyzer</a></li>
<li><a href="https://info-coach.fr/atari/software/PC-projects/steem.php" tabindex="-1">Steem</a></li>
<li><a href="https://info-coach.fr/atari/software/PC-projects/utilities.php" tabindex="-1">Utilities</a></li>
</ul></li>
<li><a class="MenuBarItemSubmenu" href="https://info-coach.fr/atari/software/ST-projects/index.php" tabindex="-1">ST-projects</a>
<ul>
<li><a href="https://info-coach.fr/atari/software/ST-projects/BIG.php" tabindex="-1" class="">BIG</a></li>
<li><a href="https://info-coach.fr/atari/software/ST-projects/Disk-Lib.php" tabindex="-1" class="">Disk-Lib</a></li>
<li><a href="https://info-coach.fr/atari/software/ST-projects/Utilities.php" tabindex="-1" class="MenuBarItemHover">Utilities</a></li>
</ul></li>
<li><a href="https://info-coach.fr/atari/software/Development.php" tabindex="-1">Development</a></li>
<li><a href="https://info-coach.fr/atari/software/preservation.php" tabindex="-1">Preservation</a></li>
<li><a href="https://info-coach.fr/atari/software/protection.php" tabindex="-1">Protection</a></li>
<li><a href="https://info-coach.fr/atari/software/Image-formats.php" tabindex="-1">Image-formats</a></li>
<li><a href="https://info-coach.fr/atari/software/GameAnalysis.php" tabindex="-1">GameAnalysis</a></li>
</ul></li>
<li><a href="https://info-coach.fr/atari/links.php" tabindex="-1">Links</a></li>
</ul>
<script type="text/javascript">
var navBar1 = new Spry.Widget.MenuBar("secNavBar", {imgDown:"/SpryAssets/SpryMenuBarDownHover.gif", imgRight:"/SpryAssets/SpryMenuBarRightHover.gif"});
</script>
  </div>
  <!-- end #header -->
  <div id="sbFloatRight">
    <h1>Table of Content </h1>
    <ul>
      <li><a href="#fd_soft_llf">Atari Low Level Formatting</a>
        <ul>
          <li><a href="#fd_soft_dd_formats">Atari / PC / ISO DD Formats</a></li>
          <li><a href="#fd_soft_atari_dd_format">Atari Standard Double Density Format</a></li>
          <li><a href="#fd_soft_standard_512B_formats">Standard 9-10-11 * 512 Bytes Sect.   Format</a></li>
          <li><a href="#fd_soft_standard_format_bytes_other">Std 128-256-512-1024 Bytes/Sect. Format</a></li>
        </ul>
      </li>
      <blockquote>
        <p><a href="#overall_desc">Overall Track/Sector Description</a></p>
      </blockquote>
      <ul>
        <li><a href="#tdesc">Track Description</a></li>
        <li><a href="#sect_id">Sector ID Description</a></li>
        <li><a href="#sect_data">Sector DATA Description</a></li>
        <li><a href="#tsplice">Track Write Splice</a></li>
        <li><a href="#ssplice">Sector Write Splice</a></li>
      </ul>
      <li></li>
      <li><a href="#atari_fd_layout">Atari High-Level Formatting</a>
      </li>
      <ul>
        <li><a href="#fd_soft_getting_fd_ready">Getting a Floppy Disk Ready</a></li>
        <li><a href="#fd_soft_bs">The Boot Sector</a></li>
        <li><a href="#fd_soft_directory">Directory Structure</a></li>
        <li><a href="#fd_soft_fat">FAT Structure</a></li>
      </ul>
      <li></li>
      <li>      </li>
      <li></li>
      <li>  </li>
    </ul>
</div>
  <div id="mainContent">
    <p>This page contains information about ST Floppy disks from a 
software "point of view": This includes  information on FD layouts, Low 
and High level FD format, 
    FD images,  etc...</p>
    <p>There is another page on the <a href="https://info-coach.fr/atari/hardware/FD-Hard.php">Hardware side of the Atari ST Floppy Disks</a> containing information on the Floppy Disk Media (down to 
    the flux level), the FD Drives, the FD controller, etc ...</p>
    <p>This information should  be specially usefull  for <a href="https://info-coach.fr/atari/software/preservation.php">duplication (backup)  or preservation (images)</a> of Atari ST diskettes (protected or not).</p>
    <p>&nbsp;</p>
<h1><a name="fd_soft_llf">Atari Low Level Formatt</a>ing</h1>
    <p>The first step in preparing a diskette involves the creation of 
the actual structures on the surface of the media that are used to hold 
the data. 
      This means recording the tracks and marking the start of each 
sector on each track. This is called <i>low-level formatting</i>, 
      and sometimes it is called "true formatting" since it is actually 
recording the format that will be used to store information on the disk.
 
      Once the floppy disk has been low-level formatted, the locations 
of the tracks and sectors on the 
    disk are fixed in place.</p>
<ul>
  <li><a href="#fd_soft_dd_formats">Atari / PC / ISO DD Formats</a></li>
  <li><a href="#fd_soft_atari_dd_format">Atari Standard Double Density Format</a></li>
  <li><a href="#fd_soft_standard_512B_formats">Standard 9-10-11 Sectors of 512 Bytes Format</a></li>
  <li><a href="#fd_soft_standard_format_bytes_other">Standards 128-256-512-1024 Bytes / Sector Format</a></li>
</ul><a href="https://info-coach.fr/atari/software/FD-Soft.php" class="btt"> Back to the top</a>
<h2><a name="fd_soft_dd_formats" id="fd_soft_dd_formats"></a>Atari / PC / ISO Formats    </h2>
<p>The Atari ST uses the Western Digital <a href="https://info-coach.fr/atari/hardware/FD-Hard.php#WD1772">WD1772 Floppy Disc Controller</a> (FDC) to 
      access the 3 1/2 inch (or to be more precise 90mm) floppy disks. Western Digital was recommending to use the <b>IBM 3740 Format </b>for Single Density diskette and to use the 
      <a href="https://info-coach.fr/atari/software/_fd-soft/ibm-fmt.gif">IBM System 34 Format</a> for Double Density diskette. Actually the default Atari Format used by the TOS is 
      slightly different (nearer to the <a href="https://info-coach.fr/atari/software/_fd-soft/iso-fmt.gif">ISO Double Density Format</a>) as it does not have an <b>IAM</b> byte (and associated GAP), 
      before the first <b>IDAM</b> sector of the track (see diagram below). <br>
      However the WD1772 ( and therefore the Atari) is capable to read 
both format without problem but the reverse is usually not true (i.e. 
floppies <i>formatted</i> on 
      early Atari machines can't be read on PCs but floppies created on PC can be read on Atari).</p>
    <p><img src="Atari%20ST%20FD%20Software%20Information_files/ibm-dd-fmt.gif" class="imageCenter" border="0">
      IBM <b>System 34</b> Double Density Format (this is the format produced on a DOS machine formatting in 720K)</p>
    <p>&nbsp;</p>
    <p><img src="Atari%20ST%20FD%20Software%20Information_files/iso-dd-fmt.gif" class="imageCenter" width="950" height="54" border="0"> ISO Double Density Format.</p>
<a href="https://info-coach.fr/atari/software/FD-Soft.php" class="btt"> Back to the top</a>
    <h2><a name="fd_soft_atari_dd_format">Atari Standard Double Density Format</a></h2>
    <p>Below is a detail description of the "<b>Standard Atari Double Density Format</b>" as created by the early TOS.<br>
      Note: There is no standard GAPS<strong> naming convention</strong>
 and it is not clear on how they must be decomposed. This document uses a
 GAP naming/numbering scheme which is a combination of the IBM and ISO 
standards with  more 
      details for the description of the GAP between the ID record and 
the DATA record. Usually only one gap is used to describe the content 
between these two records but here we decompose it into a post 
      ID gap (Gap 3a) and a pre-data gap (Gap 3b) as this allow a more 
detail description. Of course they can be easily combined into one Gap 3
 which is more conventional. Not show 
      in the diagram below when the floppy is formatted with an IAM 
(index address mark) the Gap1 is further decomposed into two gaps: A 
post index gap (Gap1a) and a post 
      IAM gap (Gap1b).</p>
    <p>&nbsp;</p>
<img src="Atari%20ST%20FD%20Software%20Information_files/atari-dd-fmt.gif" class="imageCenter" width="985" height="181" border="0">
	<p>&nbsp;</p>
	<p>The tables below indicates the standard values of the different gaps
 in a "standard" Atari diskette with 9 sectors of 512 user data bytes. 
It also 
	  indicates the minimum acceptable values of these gaps, as specified 
in the WD1772 datasheet, when formatting non standard diskettes.</p>
	<p>&nbsp;</p>
    <table cellspacing="0" bordercolor="#FFFF00" border="1" align="center">
      <tbody><tr>
        <td width="156"><b>Name</b></td>
        <td width="250"><b>Standard Values (9 sectors)</b></td>
        <td width="250"><b>Minimum Values (Datasheet)</b></td>
      </tr>
      <tr>
        <td width="156">Gap 1 Post Index</td>
        <td width="250">60 x $4E</td>
        <td width="250">32 x $4E</td>
      </tr>
      <tr>
        <td width="156">Gap 2 Pre ID</td>
        <td width="250">12 x $00 + 3 x $A1</td>
        <td width="250">8 x 00 + 3 x $A1</td>
      </tr>
      <tr>
        <td width="156">Gap 3a Post ID</td>
        <td width="250">22 x $4E</td>
        <td width="250">22 x $4E</td>
      </tr>
      <tr>
        <td width="156">Gap 3b Pre Data</td>
        <td width="250">12 x $00 + 3 x $A1</td>
        <td width="250">12 x $00 + 3 x $A1</td>
      </tr>
      <tr>
        <td width="156">Gap 4 Post Data</td>
        <td width="250">40 x $4E</td>
        <td width="250">24 x $4E</td>
      </tr>
      <tr>
        <td width="156">Gap 5 Pre Index</td>
        <td width="250">~ 664 x $4E</td>
        <td width="250">16 x $4E</td>
      </tr>
    </tbody></table>
    <p>Standard Record Gap Value (Gap 2 + Gap 3a + Gap 3b + Gap 4) = 92 Bytes / Record<br>
      Minimum Record Gap Value (Gap 2 + Gap 3a + Gap 3b + Gap 4) = 72 Bytes / Record<br>
      Standard Record Length (Record Gap + ID + DATA) = 92 + 7 + 515 = 614 bytes<br>
      Minimum Record Length (Record GAP + ID + DATA) = 72 + 7 + 515 = 594</p><a href="https://info-coach.fr/atari/software/FD-Soft.php" class="btt"> Back to the top</a>
    <h2><a name="fd_soft_standard_512B_formats">Standard 9-10-11 Sectors of 512 Bytes Format</a></h2>
    <p>Note that the 3 1/2 FD are spinning at 300 RPM which implies a 200 ms total track time. As the MFM cells have a length of 4 
    µsec this gives a total of 50000 cells and therefore about <b> 6250</b> bytes per track.</p>
    <p>The table below indicates possible (i.e. classical) values of the gaps for 
      tracks with 9, 10, and 11 sectors.</p>
    <table cellspacing="0" cellpadding="2" bordercolor="#FFFF00" border="1" align="center">
      <tbody><tr>
        <td width="200"><b>Name</b></td>
        <td width="200"><b>9 Sectors: # bytes</b></td>
        <td width="200"><b>10 Sectors: # bytes</b></td>
        <td width="200"><b>11 Sectors: # bytes</b></td>
      </tr>
      <tr>
        <td width="200">Gap 1 Post Index</td>
        <td width="200" align="center">60 x $4E</td>
        <td width="200" align="center">60 x $4E</td>
        <td width="200" align="center"><strong><em>10 x $4E</em></strong></td>
      </tr>
      <tr>
        <td width="200">Gap 2 Pre ID</td>
        <td width="200" align="center">12 x $00 + 3 x $A1</td>
        <td width="200" align="center">12 x $00 + 3 x $A1</td>
        <td width="200" align="center"><strong><em>3 x $00 + 3 x $A1</em></strong></td>
      </tr>
      <tr>
        <td width="200">Gap 3a Post ID</td>
        <td width="200" align="center">22 x $4E</td>
        <td width="200" align="center">22 x $4E</td>
        <td width="200" align="center">22 x $4E</td>
      </tr>
      <tr>
        <td width="200">Gap 3b Pre Data</td>
        <td width="200" align="center">12 x $00 + 3 x $A1</td>
        <td width="200" align="center">12 x $00 + 3 x $A1</td>
        <td width="200" align="center">12 x $00 + 3 x $A1</td>
      </tr>
      <tr>
        <td width="200">Gap 4 Post Data</td>
        <td width="200" align="center">40 x $4E</td>
        <td width="200" align="center">40 x $4E</td>
        <td width="200" align="center"><strong><em>1 x $4E</em></strong></td>
      </tr>
      <tr>
        <td width="200">Gap 2-4 (bytes)</td>
        <td width="200" align="center">92</td>
        <td width="200" align="center">92</td>
        <td width="200" align="center">44</td>
      </tr>
      <tr>
        <td width="200">Record Length (bytes)</td>
        <td width="200" align="center">614</td>
        <td width="200" align="center">614</td>
        <td width="200" align="center">566</td>
      </tr>
      <tr>
        <td width="200">Gap 5 Pre Index (bytes)</td>
        <td width="200" align="center">664</td>
        <td width="200" align="center">50</td>
        <td width="200" align="center">20</td>
      </tr>
      <tr>
        <td width="200">Total Track (bytes)</td>
        <td width="200" align="center">6250</td>
        <td width="200" align="center">6250</td>
        <td width="200" align="center">6250</td>
      </tr>
    </tbody></table>
    <p>Respecting all the minimum value on an 11 sectors / track gives a
 length of: L = Min Gap 1 + (11 x Min Record Length) + Min Gap 5 = 32 + 
6534 + 16 = 6582 (which 
      is 332 bytes <strong>above</strong> max track length). Therefore we need to decrease by about 32 bytes per sector in order to be 
      able to write such a track. For example the last column of the table above shows values 
      as used by <u>Superformat v2.2</u> program for 11 sectors/track (values analyzed with a Discovery Cartridge). 
    As you can see the track is formatted with a Gap 2 <b>reduced to 6</b> and Gap 4 <b>reduced to 1 !</b> </p>
    <p>These values do not 
      respect the minimum specified by the WD1772 datasheet but they make sense as it is <b>mandatory</b> to let enough time to the FDC between the ID block and the 
      corresponding DATA block which implies that <b>Gap 3a &amp; 3b should not be shorten</b>.&nbsp; The reduction of gap 4 plus gap 2 
      to <u>only 7 bytes</u> between a DATA block and the next ID block does not let enough time to the FDC to read the next sector on the fly but 
      this is acceptable as this sector can be read on the next rotation of the FD. This has an obviously <u>impact on performance</u> that can be minimized by using 
      sectors interleaving (<a href="#Interleaving">explain below</a>). But it is <b>somewhat dangerous </b>to
 have 
      such a short gap between the data and the next ID because the 
writing of a data block need to be perfectly calibrated or it will 
collide with 
      the next ID block. This is why such a track is actually reported 
as <b>"read only"</b> in 
      the DC documentation and is sometimes used as a protection mechanism.<br>
      Of course you have more chance to successfully write 11 sectors on
 the first track (the outer one) than on the last track (the inner one) 
as the bit 
      density gets higher in the later case. It is also important to 
have a floppy drive that have a stable and minimum rotation speed 
deviation (i.e. 
    RPM should not be more than 1% above 300).</p>
    <a href="https://info-coach.fr/atari/software/FD-Soft.php" class="btt"> Back to the top</a>
    <h2><a name="fd_soft_standard_format_bytes_other">Standard 128-256-512-1024 Bytes / Sector Format</a></h2>
    <p>The table below indicates some "classical" gaps values for 
      tracks with sectors of size of 128, 256, 512, and 1024.</p>
    <table cellspacing="0" bordercolor="#FFFF00" border="1" align="center">
      <tbody><tr>
        <td width="200" align="center"><b>Name</b></td>
        <td width="200" align="center"><b>29 sectors of 128 bytes</b></td>
        <td width="200" align="center"><b>18 sectors of 256 bytes</b></td>
        <td width="200" align="center"><b>9 Sectors of 512 bytes</b></td>
        <td width="200" align="center"><b>5 Sectors of 1024 bytes</b></td>
      </tr>
      <tr>
        <td width="200">Gap 1 Post Index</td>
        <td width="200" align="center">40</td>
        <td width="200" align="center">42</td>
        <td width="200" align="center">60</td>
        <td width="200" align="center">60</td>
      </tr>
      <tr>
        <td width="200">Gap 2 Pre ID</td>
        <td width="200" align="center">10+3</td>
        <td width="200" align="center">11+3</td>
        <td width="200" align="center">12+3</td>
        <td width="200" align="center">40+3</td>
      </tr>
      <tr>
        <td width="200">Gap 3a Post ID</td>
        <td width="200" align="center">22</td>
        <td width="200" align="center">22</td>
        <td width="200" align="center">22</td>
        <td width="200" align="center">22</td>
      </tr>
      <tr>
        <td width="200">Gap 3b Pre Data</td>
        <td width="200" align="center">12+3</td>
        <td width="200" align="center">12+3</td>
        <td width="200" align="center">12+3</td>
        <td width="200" align="center">12+3</td>
      </tr>
      <tr>
        <td width="200">Gap 4 Post Data</td>
        <td width="200" align="center">25</td>
        <td width="200" align="center">26</td>
        <td width="200" align="center">40</td>
        <td width="200" align="center">40</td>
      </tr>
      <tr>
        <td width="200">Gap 2-4</td>
        <td width="200" align="center">75</td>
        <td width="200" align="center">77</td>
        <td width="200" align="center">92</td>
        <td width="200" align="center">120</td>
      </tr>
      <tr>
        <td width="200">Record Length</td>
        <td width="200" align="center">213</td>
        <td width="200" align="center">343</td>
        <td width="200" align="center">614</td>
        <td width="200" align="center">1154</td>
      </tr>
      <tr>
        <td width="200">Gap 5</td>
        <td width="200" align="center">73</td>
        <td width="200" align="center">76</td>
        <td width="200" align="center">664</td>
        <td width="200" align="center">480</td>
      </tr>
      <tr>
        <td width="200">Total Track</td>
        <td width="200" align="center">6250</td>
        <td width="200" align="center">6250</td>
        <td width="200" align="center">6250</td>
        <td width="200" align="center">6250</td>
      </tr>
    </tbody></table>
    <p><a name="Interleaving"><strong>Interleaving</strong></a>: Normally the sector number is incremented by 1 for each record (i.e. there is no need to 
    interleave with DD like it used to be with older FD) however sectors can written be in any order.</p>
    <p><a href="https://info-coach.fr/atari/software/FD-Soft.php" class="btt"> Back to the top</a>
    </p>
    <h1><a name="overall_desc" id="overall_desc"></a>Overall Track / Sector Description</h1>
    <h2><a name="tdesc" id="tdesc"></a>Track Description</h2>
    <p><img src="Atari%20ST%20FD%20Software%20Information_files/track.png" width="1000" height="461"></p>
    <a href="https://info-coach.fr/atari/software/FD-Soft.php" class="btt"> Back to the top</a>
    <h2><a name="sect_id" id="sect_id"></a>Sector ID Segment</h2>
    <p><img src="Atari%20ST%20FD%20Software%20Information_files/id-segment.png" width="1000" height="158"></p>
    <p>&nbsp;</p>
    <ul>
      <li>ID PREAMBLE 
        <ul>
          <li>PLL SYNCH FIELD<br>
            This is a 12 bytes long field of repetitive clocked data  
bits. The preamble normally will be all zeroes of  NRZ data (encoded as 
1010. . . in MFM). During the ID preamble, the signal Read  Gate will go
 active, indicating that the incoming data pattern has to be locked  on 
to.</li>
          <li>ID SYNCH FIELD
            <br>
            The synch mark byte contains a missing  clock code 
violation, typically in MFM. The violation is detected by circuitry  to 
indicate the start of an ID Field or a Data Field. The first decoded 
byte  that does not contain all 0s after the preamble will be the synch 
mark. The  first 1 to be received is then used to byte align after the 
all zeroes  preamble. The DD format have three ID synch mark byte. On  
soft sectored drives Synch field precedes the address mark (AM). </li>
        </ul>
      </li>
      <li>ID FIELD      
        <ul>
          <li>ID ADDRESS MARK FIELD<br>
            ID Address Mark (IDAM) is required on soft  sectored drives 
to indicate the beginning of a sector, because this type of  drive does 
not have a sector pulse at the start of each sector. </li>
          <li>ID content Field      <br>
            The ID content Field format contains a track number  bytes, a
 sector number byte, a head number byte. It is  4 bytes long. </li>
          <li>ID CRC FIELD<br>
            CRC (Cyclic Redundancy Checking) code is  appended to the 
header field. The CRC consists of two bytes of the standard CRC-CCITT  
polynomial. The code detects errors in the header field. This appendage 
is basically  a protection field to make sure that the ID field contains
 valid information. </li>
        </ul>
      </li>
      <li>ID POSTAMBLE<br>
        This field is used to give the disk  controller time to 
interpret the data found in the ID field and to act upon it.  It 
provides slack for write splicing that occurs between the ID and Data  
segment. A Write splice occurs when the read/ write head starts writing 
the  data field. A splice is created each time a sector's data segment 
is written  to. The slight variations in the rotational speeds cause the
 first flux change  to occur in different positions for each write 
operation. It also allows time  in a write disk operation for the 
read/write circuitry to be switched from read  to write mode. Finally it
 allows time for the PLL circuit to re-lock on to a  fixed reference 
clock before it returns to synchronize to the preamble of the  data 
field. </li>
    </ul>
    <a href="https://info-coach.fr/atari/software/FD-Soft.php" class="btt"> Back to the top</a>
    <h2><a name="sect_data" id="sect_data"></a>Sector DATA Segment</h2>
<p><img src="Atari%20ST%20FD%20Software%20Information_files/data-segment.png" width="1000" height="154"></p>
<p>&nbsp;</p>
<ul>
  <li>Data PREAMBLE FIELD    
    <ul>
      <li>PLL Synch Field
        <br>
        The Data Preamble field is necessary when  reading a sector's 
data. It ensures that the PLL circuit locks on to the Data  segment data
 rate. Initially, the ID segment and the data segment of every  sector 
will be written when formatting the disk, but the Data segment will be  
written over later. Due to drive motor speed variations within the 
tolerance  specified, the ID and Data segments will have slightly 
different data rates  because they are written at different times. This 
implies that the PLL must  adjust its frequency and phase in order to 
lock on to the data rate of the Data  segment before the incoming 
preamble field has finished. Hence the need for a  second preamble field
 in the sector. </li>
      <li>DATA SYNCH FIELD
        <br>
        Following the PLL Synch Field will be the Data  synch field similar to the ID synch field.</li>
    </ul>
  </li>
  <li>DATA FIELD 
    <ul>
      <li>Data Address Mark field<br>
        Following the Data Preamble will be the  Data Address Mark for 
soft sectored drives similar to the ID Address Mark  field. </li>
      <li>Data Content Field<br>
        The Data field is transferred to or from  external memory. It is usually from 128 bytes to 1024 bytes per sector.</li>
      <li>DATA CRC<br>
        A CRC appendage follows the Data field. CRC  generating (when 
writing to the disk) and checking (when reading from the disk)  are 
performed on the Data field. Errors may therefore be detected. </li>
    </ul>
  </li>
  <li>DATA POSTAMBLE FIELD <br>
    This has the same  function as the ID Postamble field. It is the 
final field of the sector. It  allows slack between neighboring sectors.
 Without this gap, whenever a data  segment is written to a sector, any 
reduction in drive motor speed at the  instance of writing to the disk 
would cause an overlap of the data segment and  the succeeding ID 
segment of the next sector. This field is only written when  formatting 
the disk. </li>
</ul>
    <p>Note 1: A final gap field is added from the end of the last 
sector  until the INDEX pulse occurs and this gap is often termed Gap 5.
 It takes up  the slack from the end of the last sector to the Index 
pulse.</p>
    <p>Note 2: When writing a sector the write gate is tunrned on at the
 begining of the DATA preamble (location of the write splicing) and is 
turned off in the data postamble (one or two bytes after the last CRC).</p>
    <a href="https://info-coach.fr/atari/software/FD-Soft.php" class="btt"> Back to the top</a>
<h2><a name="ssplice" id="ssplice"></a>Sector Write Splice</h2>
    <p>The area at the begining of the DATA preamble provides slack for 
write splicing that occurs between the ID and Data  segment. A Write 
splice occurs when the read/ write head starts writing the  data field. A
 splice is created each time a sector's data segment is written  to. The
 slight variations in the rotational speeds cause the first flux change 
 to occur in different positions for each write operation. It also 
allows time  in a write disk operation for the read/write circuitry to 
be switched from read  to write mode. </p>
    <a href="https://info-coach.fr/atari/software/FD-Soft.php" class="btt"> Back to the top</a>
    <h2><a name="tsplice" id="tsplice"></a>Track Write Splice    </h2>
    <p>A Track write splice occurs when writing a complete track. When 
you write a whole track, you start writing bytes at the index mark  for 
200ms. The problem is that floppy drives do not run exactly at 300 rpm 
all the time, so there's pretty much no chance you'll get an exact 
joining once you've done a complete revolution. So you'll either have 
some leftover noise just before your starting point, or some overwriting
 there.</p>
    <a href="https://info-coach.fr/atari/software/FD-Soft.php" class="btt"> Back to the top</a>
<h1><a name="atari_fd_layout">Atari High-Level Formating</a></h1>
    <p><a href="#fd_soft_getting_fd_ready">Getting a Floppy Disk Ready</a></p>
    <p><a href="#fd_soft_bs">The Boot Sector</a></p>
    <p><a href="#fd_soft_directory">Directory Structure</a></p>
    <p><a href="#fd_soft_fat">FAT Structure</a>    </p>
    <h2><a name="fd_soft_getting_fd_ready"> Getting a floppy disk ready</a></h2>
    <p>There are two steps involved in getting a floppy disks ready for usage on an Atari:</p>
    <ul>
      <li>As already  described <a href="#fd_soft_llf">in this section</a>
 the first step involves the creation of the actual structures on the 
surface of the media that are used to hold the data ans is called the <em>Low_Level formatting</em>.</li>
      <li>The second  step is called the <i>high-level formatting</i>. This is the process of creating the disk's logical structures such as the 
        <a href="#fd_soft_fat">file allocation table</a> and <a href="#fd_soft_directory">root directory</a>.
 The high-level format uses the structures created by the 
        low-level format to prepare the disk to hold files using the 
chosen file system. In order for the TOS to use a diskette it has to 
know about the number of 
        tracks, the number of sectors per tracks, the size of the 
sectors and the number of sides. This information is defined in a 
special sector called the <b>
        <a href="#fd_soft_bs">boot sector</a></b>. Beyond that it is 
necessary for the TOS&nbsp; to find information (e.g. location of all 
the sectors 
        belonging to this file, attributes, ...) about any files stored 
on the diskette as well as global information (e.g. the space still 
available on the diskette). 
        This information is kept in <b><a href="#fd_soft_directory">directories</a></b> and <b> <a href="#fd_soft_fat">FATs</a></b> structures.</li>
    </ul>
<p><a href="https://info-coach.fr/atari/software/FD-Soft.php" class="btt"> Back to the top</a>
</p>
    <h2><a name="fd_soft_bs">The Boot Sector</a> (BS)</h2>
    <p>The boot sector is always located on track 0, side 0, first 
sector of the diskette. This sector is tested by the TOS&nbsp; as soon 
as you change of 
      diskette to find important information about the diskette (e.g. it
 contains a serial number that identify the diskette). Some parameters 
are loaded from this sector to 
      be used by the BIOS and are stored in a structure called the BPB 
(Bios Parameter Block). Eventually the boot sector also contain a 
bootstrap routine (the loader) that 
      allow to start a relocatable program a boot time (usually a TOS 
image).</p>
    <p>The structure of the boot sector is described below (<span style="background-color: #808080">the grayed areas are stored in the BPB</span>).
 Note that the Atari 
        boot sector is similar with the boot sector used by IBM PC and 
therefore 16 bits words are stored using the low/high bytes <font color="#00FF00">Intel</font> 
      format&nbsp; (e.g. a BPS = $00 $02 indicates a $200 bytes per sector).</p>
<table id="table43" cellspacing="0" bordercolor="#FFFF00" border="1">
      <tbody><tr>
        <th style="border-color: #FFFF00" width="120" align="left">Name</th>
        <th style="border-color: #FFFF00" width="70"> <b>Offset</b> </th>
        <th style="border-color: #FFFF00" width="70" align="left">Bytes</th>
        <th style="border-color: #FFFF00" width="800" align="left"><b>Contents</b></th>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" align="left"><b>BRA</b></th>
        <td width="70" valign="top" align="center"> $00 </td>
        <td width="70" valign="top" align="left">2</td>
        <td width="800" valign="top" align="left">This <b>word</b> contains a 
          680x0 BRA.S instruction to the bootstrap code in this sector if the disk is 
          executable, otherwise it is unused. </td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" align="left"><b>OEM</b></th>
        <td width="70" valign="top" align="left">$02 </td>
        <td width="70" valign="top" align="left">6</td>
        <td width="800" valign="top" align="left">These six bytes are reserved 
          for use as any necessary filler information. The disk-based <b>TOS</b> loader program places the string 'Loader' here. </td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" align="left"><b>SERIAL</b></th>
        <td width="70" valign="top" align="left">$08 </td>
        <td width="70" valign="top" align="left">4</td>
        <td width="800" valign="top" align="left">The low 24-bits of this <b>long</b> represent a unique disk serial number. </td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#808080" align="left"><b>BPS</b></th>
        <td width="70" valign="top" bgcolor="#808080" align="left">$0B </td>
        <td width="70" valign="top" bgcolor="#808080" align="left"> 2</td>
        <td width="800" valign="top" bgcolor="#808080" align="left">This is an 
          Intel format <b>word</b> (low byte first) which indicates the number of 
          bytes per sector on the disk (usually 512).</td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#808080" align="left"><b>SPC</b></th>
        <td width="70" valign="top" bgcolor="#808080" align="left">$0D </td>
        <td width="70" valign="top" bgcolor="#808080" align="left">1</td>
        <td width="800" valign="top" bgcolor="#808080" align="left">This is a <b>byte</b> which indicates the number of sectors per cluster on the disk. 
          Must be a power of 2 (usually 2)</td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" height="42" bgcolor="#808080" align="left"> <b>RESSEC</b></th>
        <td width="70" valign="top" height="42" bgcolor="#808080" align="left">$0E </td>
        <td width="70" valign="top" height="42" bgcolor="#808080" align="left">2</td>
        <td width="800" valign="top" height="42" bgcolor="#808080" align="left">This is an 
          Intel format <b>word</b> which indicates the number of reserved sectors 
          at the beginning of the media preceding the start of the first FAT, 
          including the boot sector itself. It is usually one for floppies.</td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#808080" align="left"><b>NFATS</b></th>
        <td width="70" valign="top" bgcolor="#808080" align="left">$10 </td>
        <td width="70" valign="top" bgcolor="#808080" align="left">1</td>
        <td width="800" valign="top" bgcolor="#808080" align="left">This is a <b>byte</b> indicating the number of File Allocation Table's (FAT's) stored 
          on the disk. Usually the value is two as one extra copy of the FAT is 
          kept to recover data if the first FAT gets corrupted.</td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#808080" align="left"><b>NDIRS</b></th>
        <td width="70" valign="top" bgcolor="#808080" align="left">$11 </td>
        <td width="70" valign="top" bgcolor="#808080" align="left">2</td>
        <td width="800" valign="top" bgcolor="#808080" align="left">This is an 
          Intel format <b>word</b> indicating the total number of file name 
          entries that can be stored in the root directory of the volume.</td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#808080" align="left"><b>NSECTS</b></th>
        <td width="70" valign="top" bgcolor="#808080" align="left">$13 </td>
        <td width="70" valign="top" bgcolor="#808080" align="left">2</td>
        <td width="800" valign="top" bgcolor="#808080" align="left">This is an 
          Intel format <b>word</b> indicating the number of sectors on the disk 
          (including those reserved). </td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#808080" align="left"><b>MEDIA</b></th>
        <td width="70" valign="top" bgcolor="#808080" align="left">$15 </td>
        <td width="70" valign="top" bgcolor="#808080" align="left">1</td>
        <td width="800" valign="top" bgcolor="#808080" align="left">This <b>byte</b> is the media descriptor. For hard disks this value is set to 0xF8, otherwise it 
          is unused on Atari. </td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#808080" align="left"><b>SPF</b></th>
        <td width="70" valign="top" bgcolor="#808080" align="left">$16 </td>
        <td width="70" valign="top" bgcolor="#808080" align="left">2</td>
        <td width="800" valign="top" bgcolor="#808080" align="left">This is an 
          Intel format <b>word</b> indicating the number of sectors occupied by 
          each of the FATs on 
          the volume. Given this information, together with the number of FATs and 
          reserved sectors listed above, we can compute where the <a href="#fd_soft_directory"> <i>root directory</i> </a>begins. Given the number of entries in the root directory, we can also 
          compute where the user data area of the disk begins.</td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#808080" align="left"><b>SPT</b></th>
        <td width="70" valign="top" bgcolor="#808080" align="left">$18 </td>
        <td width="70" valign="top" bgcolor="#808080" align="left">2</td>
        <td width="800" valign="top" bgcolor="#808080" align="left">This is an 
          Intel format <b>word</b> indicating the number of sectors per track 
          (usually 9)</td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#808080" align="left"><b>NHEADS</b></th>
        <td width="70" valign="top" bgcolor="#808080" align="left">$1A </td>
        <td width="70" valign="top" bgcolor="#808080" align="left">2</td>
        <td width="800" valign="top" bgcolor="#808080" align="left">This is an 
          Intel format <b>word</b> indicating the number of heads on the disk. For 
          a single side diskette the value is 1 and for a double sided diskette 
          the value is&nbsp; 2.</td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#808080" align="left"><b>NHID</b></th>
        <td width="70" valign="top" bgcolor="#808080" align="left">$1C </td>
        <td width="70" valign="top" bgcolor="#808080" align="left">2</td>
        <td width="800" valign="top" bgcolor="#808080" align="left">This is an 
          Intel format <b>word</b> indicating the number of hidden sectors on a 
          disk (not used by Atari). </td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#FFCC00" align="left"> <font color="#000000">EXECFLAG</font></th>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">$1E</font></td>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">2</font></td>
        <td width="800" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">This is&nbsp; 
          a<b> word </b>which is loaded in the <b>cmdload </b>system 
          variable. This flag is used to find out if the command.prg program has 
          to be started after loading the OS.</font></td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#FFCC00" align="left"> <font color="#000000">LDMODE</font></th>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">$20</font></td>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">2</font></td>
        <td width="800" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">This is&nbsp; 
          a <b>word </b>indicating the load mode. If this flag equal 
zero 
          the file specified by the FNAME field is located and loaded 
(usually the file is TOS.IMG). If the flag is not equal to zero the 
sectors as 
          specified by SECTCNT and SSSECT variables are loaded.</font></td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#FFCC00" align="left"> <font color="#000000">SSECT</font></th>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">$22</font></td>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">2</font></td>
        <td width="800" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">This is&nbsp; 
          an Intel format <b>word </b>indicating the logical sector from where we 
          boot. This variable is only used if LDMODE is not equal to zero</font></td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#FFCC00" align="left"> <font color="#000000">SECTCNT</font></th>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">$24</font></td>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">2</font></td>
        <td width="800" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">This is&nbsp; 
          an Intel format <b>word </b>indicating the number of sectors to load for 
          the boot. This variable is only used if LDMODE is not equal to zero</font></td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#FFCC00" align="left"> <font color="#000000">LDAADDR</font></th>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">$26</font></td>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">2</font></td>
        <td width="800" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">This is&nbsp; 
          an Intel format <b>word </b>indicating the memory address where the boot 
          program will be loaded.</font></td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#FFCC00" align="left"> <font color="#000000">FATBUF</font></th>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">$2A</font></td>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">2</font></td>
        <td width="800" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">This is&nbsp; 
          an Intel format <b>word </b>indicating the address where the FAT and 
          catalog sectors must be loaded</font></td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#FFCC00" align="left"> <font color="#000000">FNAME</font></th>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">$2E</font></td>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">11</font></td>
        <td width="800" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">This is the 
          name of an image file that must be loaded when LDMODE equal zero. It has 
          exactly the same structure as a normal file name, that is 8 characters 
          for the name and 3 characters for the extension.</font></td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#FFCC00" align="left"> <font color="#000000">RESERVED</font></th>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">$39</font></td>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">2</font></td>
        <td width="800" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">Reserved</font></td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" bgcolor="#FFCC00" align="left"> <font color="#000000">BOOTIT</font></th>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">$3A</font></td>
        <td width="70" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">452</font></td>
        <td width="800" valign="top" bgcolor="#FFCC00" align="left"><font color="#000000">Boot program 
          that can eventually be loaded after loading of the boot sector.</font></td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" align="left"><b>CHECKSUM</b></th>
        <td width="70" valign="top" align="left">$1FE </td>
        <td width="70" valign="top" align="left">2</td>
        <td width="800" valign="top" align="left">The entire boot sector <b>word</b> summed with this Motorola format <b>word</b> will equal 0x1234 if the 
          boot sector is executable or some other value if not. </td>
      </tr>
    </tbody></table>
<p>The data beginning at offset $1E (<font color="#000000"><span style="background-color: #FFCC00">colored in yellow</span></font>) are only used for a 
      <b>bootable diskette</b>. To recognize that a diskette is bootable the boot sector must contain the text "Loader" starting at the third bytes 
        and the sum of the entire boot sector should be equal to $1234.</p>
<p>The boot process is usually done in 4 stages:</p>
<ol>
  <li>The boot sector is loaded and the boot program contained is executed.</li>
  <li>The FAT and the catalog are loaded from the diskette and the loader 
    search for the file name indicated</li>
  <li>The program image is loaded usually starting with address $40000</li>
  <li>The loaded program is executed from the beginning.</li>
</ol>
<p>See also some <a href="https://info-coach.fr/atari/software/_fd-soft/bootsector.txt">Boot sector code</a>.</p>
<ul>
  <li><a href="https://info-coach.fr/atari/software/FD-Soft.php" class="btt"> Back to the top</a>
  </li>
  </ul>
<h2><a name="fd_soft_directory">Directory Structure</a></h2>
<p>The TOS arranges and stores file-system contents in directories. Every file system has at least one directory, called the <b>root directory </b>(also
 
  referred as the catalog in Atari), and may have additional directories
 either in the root directory or ordered hierarchically below it. The 
contents 
  of each directory are described in individual directory entries. The 
TOS strictly controls the format and content of directories.<br>
  The <b>root directory </b>is always the topmost directory. The TOS creates the root directory when it formats the storage medium (
  <a href="#fd_soft_getting_fd_ready">high level formatting</a>). The root directory can hold information for only a <u>fixed number 
    of files or other directories</u>, and the number cannot be changed without reformatting the medium. A program can identify this limit by examining 
  the <b>NDIRS </b>field in the BPB structure described in the <a href="#fd_soft_bs">boot sector</a> section. This field specifies the maximum 
  number of root-directory entries for the medium.<br>
  A user or a program program can add new directories within the current
 directory, or within other directories. Unlike the root directory, the 
new 
  directory is limited only by the amount of space available on the 
medium, not by a fixed number of entries. The TOS initially allocates 
only a 
  single cluster for the directory, allocating additional clusters only 
when they are needed. Every directory except the root directory has two 
  entries when it is created. The first entry specifies the directory 
itself, and the second entry specifies its parent directory—the 
directory that 
  contains it. These entries use the special directory names ". "(an 
ASCII period) and ".." (two ASCII periods), respectively.</p>
<p>The TOS gives programs access to files in the file system. Programs 
can read from and write to existing files, as well as create new ones. 
Files 
  can contain any amount of data, up to the limits of the storage 
medium. Apart from its contents, every file has a name (possibly with an
 extension), 
  access attributes, and an associated date and time. This information 
is stored in the file's directory entry, not in the file itself.</p>
<p>The <b><font color="#00FF00">root directory </font></b>is located just after the <a href="#fd_soft_fat">FATs</a>
 (i.e. on a single sided FD: 
  side 0, track 1, sector 3 and on DS DF side 1, track 0, sector 3) and 
is composed of 7 sectors. Each entry in the root directory can be 
describe by the 
  following structure:</p>
    <table id="table44" cellspacing="0" bordercolor="#FFFF00" border="2">
      <tbody><tr>
        <th style="border-color: #FFFF00" width="120" align="left">Name</th>
        <th style="border-color: #FFFF00" width="70" align="left">Bytes</th>
        <th style="border-color: #FFFF00" width="800" align="left"><b>Contents</b></th>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" align="left">FNAME</th>
        <td width="70" valign="top" align="left">8</td>
        <td width="800" valign="top" align="left">Specifies the name of 
the file or directory. If the file or directory was created by using a 
name with 
          fewer than eight characters, space characters (ASCII $20) fill
 the remaining bytes in the field. The first byte in the field can be a 
          character or one of the following values:
          <ul>
            <li>$00 The directory entry has never been used. The TOS uses this value 
              to limit the length of directory searches.</li>
            <li>$05 The first character in the name has the value 0E5h.</li>
            <li>$2E The directory entry is an alias for this directory or the 
              parent directory. If the remaining bytes are space characters (ASCII 20h), the <b>SCLUSTER</b> field contains the starting cluster for 
              this directory. If the second byte is also 2Eh (and the remaining bytes are space characters), <b>SCLUSTER</b> contains the starting 
            cluster number of the parent directory, or zero if the parent is the root directory.</li>
            <li>E5h The file or directory has been deleted.</li>
          </ul></td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" align="left">FEXT</th>
        <td width="70" valign="top" align="left">3</td>
        <td width="800" valign="top" align="left">Specifies the file or directory extension. If the extension has fewer than three characters, 
        space characters (ASCII $20) fill the remaining bytes in this field.</td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" align="left">ATTRIB</th>
        <td width="70" valign="top" align="left">1</td>
        <td width="800" valign="top" align="left">Specifies the attributes of 
          the file or directory. This field can contain some combination of the 
          following values:
          <ul>
            <li>&nbsp;$01 Specifies a read-only file.</li>
            <li>&nbsp;$02 Specifies a hidden file or directory.</li>
            <li>&nbsp;$04 Specifies a system file or directory.</li>
            <li>&nbsp;$08 Specifies a volume label. The directory entry 
contains no other usable information (except for date and time of 
creation) 
            and can occur only in the root directory.</li>
            <li>&nbsp;$10 Specifies a directory.</li>
            <li>&nbsp;$20 Specifies a file that is new or has been modified.</li>
            <li>&nbsp;All other values are reserved. (The two high-order
 bits are set to zero.) If no attributes are set, the file is a normal 
file.</li>
          </ul></td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" align="left">RES</th>
        <td width="70" valign="top" align="left">10</td>
        <td width="800" valign="top" align="left">Reserved; do not use.</td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" align="left">FTIME</th>
        <td width="70" valign="top" align="left">2</td>
        <td width="800" valign="top" align="left">Specifies the time the file or 
          directory was created or last updated. The field has the following form:
          <ul>
            <li>&nbsp;bits 0-4 Specifies two-second intervals. Can be a value in 
              the range 0 through 29.</li>
            <li>&nbsp;bits 5-10 Specifies minutes. Can be a value in the range 0 
              through 59.</li>
            <li>&nbsp;bits 11-15 Specifies hours. Can be a value in the range 0 
              through 23.</li>
          </ul></td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" align="left">FDATE</th>
        <td width="70" valign="top" align="left">2</td>
        <td width="800" valign="top" align="left">Specifies the date the file or 
          directory was created or last updated. The field has the following form:
          <ul>
            <li>&nbsp;bits 0-4 Specifies the day. Can be a value in the range 1 
              through 31.</li>
            <li>&nbsp;bits 5-8 Specifies the month. Can be a value in the range 
              1 through 12.</li>
            <li>&nbsp;bits 9-15 Specifies the year, relative to 1980.</li>
          </ul></td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" align="left">SCLUSTER</th>
        <td width="70" valign="top" align="left">2</td>
        <td width="800" valign="top" align="left">Specifies the starting cluster 
          of the file or directory (index into the <a href="#fd_soft_fat">FAT</a>)</td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" align="left">FSIZE</th>
        <td width="70" valign="top" align="left">4</td>
        <td width="800" valign="top" align="left">Specifies the maximum size of 
          the file, in bytes.</td>
      </tr>
    </tbody></table>
    <ul>
      <li><a href="https://info-coach.fr/atari/software/FD-Soft.php" class="btt"> Back to the top</a>
      </li>
    </ul>
    <h2><a name="fd_soft_fat">FAT Structure</a></h2>
    <p>The file allocation table (FAT) is an array used by the TOS to keep track of 
        which clusters on a drive have been allocated for each file or directory. As a 
        program creates a new file or adds to an existing one, the system allocates 
        sectors for that file, writes the data to the given sectors, and keeps track of 
        the allocated sectors by recording them in the FAT. To conserve space and speed 
        up record-keeping, each record in the FAT corresponds to two or more consecutive 
        sectors (called a cluster). The number of sectors in a cluster depends on the 
        type and capacity of the drive but is always a power of 2. Every logical drive 
        has at least one FAT, and most drives have two, one serving as a backup should 
        the other fail. The FAT immediately follows the <a href="#fd_soft_bs">boot 
          sector </a>and any other reserved sectors.</p>
    <p>Depending on the number of clusters on the drive, the FAT consists of an 
        array of either 12-bit or 16-bit entries. Drives with more than 4086 clusters 
        have a 16-bit FAT; those with 4086 or fewer clusters have a 12-bit FAT. As Atari 
        diskette has always less than 4086 clusters the FATs<b>on 
          Atari diskettes are always 
          12-bit FATs</b>.</p>
    <p>The first two entries in a FAT (3 bytes for a 12-bit FAT) are 
reserved. In 
        most cases the first byte contains the media descriptor (usually
 $F9F) and the 
        additional reserved bytes are set to $FFF. Each FAT entry 
represents a corresponding cluster on the drive. If the cluster 
        is part of a file or directory, the entry contains either a 
marker specifying 
        the cluster as the last in that file or directory, or an index 
pointing to the 
        next cluster in the file or directory. If a cluster is not part 
of a file or 
        directory, the entry contains a value indicating the cluster's 
status. </p>
    <p>The following table shows possible FAT entry values:</p>
    <table id="table45" bordercolor="#FFFF00" border="1">
      <tbody><tr>
        <th style="border-color: #FFFF00" width="120" align="left">Value</th>
        <th style="border-color: #FFFF00" width="800" align="left">Meaning</th>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" align="left">$000</th>
        <td width="800" valign="top" align="left">Available cluster.</td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" align="left">$002-$FEF</th>
        <td width="800" valign="top" align="left">Index of entry for the next 
          cluster in the file or directory. Note that $001 does not appear in a 
          FAT, since that value corresponds to the FAT's second reserved entry. 
          Index numbering is based on the beginning of the FAT</td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" height="24" align="left">$FF0-$FF6</th>
        <td width="800" valign="top" height="24" align="left">Reserved</td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" align="left">$FF7</th>
        <td width="800" valign="top" align="left">Bad sector in cluster; do not 
          use cluster.</td>
      </tr>
      <tr>
        <th style="border-color: #FFFF00" width="120" valign="top" align="left">$FF8-$FFF</th>
        <td width="800" valign="top" align="left">Last cluster of file or 
          directory. (usually the value $FFF is used)</td>
      </tr>
    </tbody></table>
    <p>Each file and directory consists of one or more clusters, each cluster 
        represented by a single entry in the FAT. The <b>SCLUSTER</b> field in the <a href="#fd_soft_directory"><i>directories</i> <i>structure</i></a> corresponding to the file or directory specifies the index of the first FAT 
        entry for the file or directory. This entry contains $FFF if there are no 
        further FAT entries for that file or directory, or it contains the index of the 
        next FAT entry for the file or directory. For example, the following segment of 
        a 12-bit FAT shows the FAT entries for a file consisting of four clusters:</p>
    <ul>
      <li>&nbsp;$003 Cluster 2 points to cluster 3</li>
      <li>&nbsp;$005 Cluster 3 points to cluster 5</li>
      <li>&nbsp;$FF7 Cluster 4 contains a bad sector</li>
      <li>&nbsp;$006 Cluster 5 points to cluster 6</li>
      <li>&nbsp;$FFF Cluster 6 is the last cluster for the file</li>
      <li>&nbsp;$000 Clusters 7 is available</li>
      <li>&nbsp;...</li>
    </ul>
    <p>Note that if a cluster contains $000 it does not mean that it is empty but 
        that it is available. This is due to the fact that when a file is deleted the 
        data are not erased but only the first letter of the name of the file in the 
        directory structure is set to $E5 and all clusters used by the deleted file are 
        set to $000.</p>
    <p><a href="https://info-coach.fr/atari/software/FD-Soft.php" class="btt"> Back to the top</a>
    </p>
  </div>
<div id="footer">
    <h1>Copyright and Fair Use Notice </h1>
    <p>This site contains copyrighted material the use of which has not 
      always been specifically authorized by the copyright owner. We are making such 
      material available in our efforts to help in the understanding of&nbsp;the Atari 
      Computers. We believe this constitutes a 'fair use' of any such copyrighted 
      material. The material on this site is accessible without profit and is 
      presented here with the only goal to disseminate knowledge about Atari 
      computers. Consistent with this notice you are welcome to make 'fair use' of 
      anything you find on this web site. However, all persons reproducing, 
      redistributing, or making commercial use of this information are expected to 
      adhere to the terms and conditions asserted by the copyright holder. 
      Transmission or reproduction of protected items beyond that allowed by fair use 
      notice as defined in the copyright laws requires the permission of the copyright 
      owners. </p>
    <p>© Info-Coach - DrCoolZic (Jean Louis-Guérin)</p>
  </div>
  <!-- end #footer --> 
</div>


</body></html>